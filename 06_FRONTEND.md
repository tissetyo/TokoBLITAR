# 06_FRONTEND.md
> Build the frontend exactly as structured here. Do not invent new patterns — follow what's specified.

---

## INSTALL COMMANDS — RUN IN ORDER

```bash
# 1. Create project
npx create-next-app@latest tokoblitar --typescript --tailwind --app --src-dir --no-import-alias

# 2. Core deps
npm install @supabase/supabase-js @supabase/ssr
npm install @tanstack/react-query @tanstack/react-query-devtools
npm install zustand
npm install react-hook-form @hookform/resolvers zod
npm install framer-motion
npm install @tiptap/react @tiptap/pm @tiptap/starter-kit
npm install date-fns
npm install lucide-react
npm install @aws-sdk/client-s3 @aws-sdk/s3-request-presigner
npm install @anthropic-ai/sdk

# 3. shadcn/ui
npx shadcn@latest init   # choose: Default style, Slate base, yes CSS vars
npx shadcn@latest add button card input textarea select dialog sheet drawer
npx shadcn@latest add table badge avatar skeleton tabs toast progress
npx shadcn@latest add form label separator tooltip popover

# 4. Supabase CLI
npm install -g supabase
supabase login
supabase init
supabase link --project-ref YOUR_PROJECT_REF
supabase gen types typescript --linked > src/types/supabase.ts
```

---

## EXACT FOLDER STRUCTURE

```
src/
  app/
    (auth)/
      login/
        page.tsx
        loading.tsx
      register/
        page.tsx
    (buyer)/
      page.tsx                        # Homepage - ISR revalidate 60s
      loading.tsx
      products/
        page.tsx                      # Search + filter
        [id]/
          page.tsx                    # SSR product detail
      cart/
        page.tsx
      checkout/
        page.tsx
      orders/
        [id]/
          page.tsx                    # Order tracking - realtime
      profile/
        page.tsx
    (seller)/
      dashboard/
        layout.tsx                    # Nav + AI sidebar shell
        page.tsx                      # Stats overview
        store/page.tsx
        products/
          page.tsx
          new/page.tsx
          [id]/page.tsx
        marketplace/page.tsx
        instagram/page.tsx
        promo/page.tsx
        orders/page.tsx
        shipping/page.tsx
    (admin)/
      admin/
        layout.tsx
        dashboard/page.tsx
        stores/page.tsx
        products/page.tsx
        promo/page.tsx
        banners/page.tsx
    store/
      [slug]/
        page.tsx                      # Public store page - SSR
    api/                              # (see 04_BACKEND.md)
    layout.tsx                        # Root layout - fonts, providers
    globals.css                       # Design tokens

  components/
    layout/
      Header.tsx
      Footer.tsx
      SellerNav.tsx                   # Left sidebar nav
      AISidebar.tsx                   # AI chat panel
      DashboardLayout.tsx             # Wraps nav + main + AI
    seller/
      ProductForm.tsx                 # Create/edit product
      PhotoEnhancer.tsx               # Before/after AI photo
      MarketplaceCard.tsx
      PromoForm.tsx
      InstagramEditor.tsx
      OnboardingStepper.tsx           # 6-step store setup
    buyer/
      ProductCard.tsx
      StoreCard.tsx
      CartItem.tsx
      OrderTracker.tsx                # Stepper with realtime
      MembershipCard.tsx
      QrisPayment.tsx                 # QR display + polling
    shared/
      SearchBar.tsx
      CategoryFilter.tsx
      ImageUpload.tsx                 # Drag-drop → R2 upload
      MapPicker.tsx                   # Google Maps location
      DataTable.tsx                   # Sortable + filter table
      StatusBadge.tsx
      StatCard.tsx
      SkeletonCard.tsx
      ErrorBoundary.tsx

  store/
    cartStore.ts
    aiSessionStore.ts
    uiStore.ts                        # sidebar open, modal states

  hooks/
    useProducts.ts
    useStore.ts
    useOrders.ts
    useAI.ts                          # SSE streaming hook
    useCart.ts
    useRealtime.ts                    # Supabase Realtime subscriptions
    useImageUpload.ts                 # Upload to R2

  lib/
    supabase/
      client.ts                       # Browser client (singleton)
      server.ts                       # Server client + getServerUser()
      middleware.ts
    r2.ts                             # Upload/delete from Cloudflare R2
    encrypt.ts                        # AES-256 for marketplace tokens
    rate-limit.ts                     # Upstash Redis limiter
    midtrans.ts                       # Payment helpers
    kiriminaja.ts                     # Shipping API helpers
    utils.ts                          # cn(), formatPrice(), formatDate()

  types/
    index.ts                          # All types (re-export from supabase.ts + custom)
    supabase.ts                       # Generated by supabase gen types
```

---

## ROOT LAYOUT

```tsx
// app/layout.tsx
import { Inter } from 'next/font/google'
import { Providers } from '@/components/Providers'
import './globals.css'

const inter = Inter({ subsets: ['latin'], variable: '--font-sans' })

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="id">
      <body className={inter.variable}>
        <Providers>{children}</Providers>
      </body>
    </html>
  )
}

// components/Providers.tsx — wraps QueryClient + Toaster
'use client'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { Toaster } from '@/components/ui/sonner'
const queryClient = new QueryClient()
export function Providers({ children }) {
  return (
    <QueryClientProvider client={queryClient}>
      {children}
      <Toaster position="top-right" />
    </QueryClientProvider>
  )
}
```

---

## STATE MANAGEMENT

### cartStore.ts
```ts
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

interface CartItem { product_id: string; name: string; price: number; quantity: number; image_url: string }

interface CartStore {
  items: CartItem[]
  addItem: (item: CartItem) => void
  removeItem: (product_id: string) => void
  updateQty: (product_id: string, quantity: number) => void
  clear: () => void
  total: () => number
}

export const useCartStore = create<CartStore>()(
  persist(
    (set, get) => ({
      items: [],
      addItem: (item) => set((s) => {
        const exists = s.items.find(i => i.product_id === item.product_id)
        if (exists) return { items: s.items.map(i => i.product_id === item.product_id ? { ...i, quantity: i.quantity + item.quantity } : i) }
        return { items: [...s.items, item] }
      }),
      removeItem: (id) => set((s) => ({ items: s.items.filter(i => i.product_id !== id) })),
      updateQty: (id, qty) => set((s) => ({ items: s.items.map(i => i.product_id === id ? { ...i, quantity: qty } : i) })),
      clear: () => set({ items: [] }),
      total: () => get().items.reduce((sum, i) => sum + i.price * i.quantity, 0),
    }),
    { name: 'tokoblitar-cart' }
  )
)
```

### aiSessionStore.ts
```ts
import { create } from 'zustand'

interface Message { id: string; role: 'user' | 'assistant'; content: string; isStreaming?: boolean }

interface AIStore {
  messages: Message[]
  isOpen: boolean
  isStreaming: boolean
  addMessage: (msg: Omit<Message, 'id'>) => string
  updateMessage: (id: string, content: string) => void
  toggleSidebar: () => void
  setStreaming: (v: boolean) => void
  clear: () => void
}

export const useAIStore = create<AIStore>((set) => ({
  messages: [],
  isOpen: true,
  isStreaming: false,
  addMessage: (msg) => {
    const id = crypto.randomUUID()
    set((s) => ({ messages: [...s.messages, { ...msg, id }] }))
    return id
  },
  updateMessage: (id, content) => set((s) => ({
    messages: s.messages.map(m => m.id === id ? { ...m, content } : m)
  })),
  toggleSidebar: () => set((s) => ({ isOpen: !s.isOpen })),
  setStreaming: (v) => set({ isStreaming: v }),
  clear: () => set({ messages: [] }),
}))
```

---

## AI SIDEBAR — useAI HOOK

```ts
// hooks/useAI.ts
'use client'
import { useQueryClient } from '@tanstack/react-query'
import { useAIStore } from '@/store/aiSessionStore'

export function useAI() {
  const { addMessage, updateMessage, setStreaming } = useAIStore()
  const queryClient = useQueryClient()

  async function sendMessage(text: string) {
    addMessage({ role: 'user', content: text })
    const aiMsgId = addMessage({ role: 'assistant', content: '', isStreaming: true })
    setStreaming(true)

    const res = await fetch('/api/ai/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ message: text }),
    })

    const reader = res.body!.getReader()
    const decoder = new TextDecoder()
    let fullText = ''

    while (true) {
      const { done, value } = await reader.read()
      if (done) break
      const chunk = decoder.decode(value)
      const lines = chunk.split('\n').filter(l => l.startsWith('data: '))
      for (const line of lines) {
        const data = line.replace('data: ', '')
        if (data === '[DONE]') break
        try {
          const { text: t } = JSON.parse(data)
          fullText += t
          updateMessage(aiMsgId, fullText)
        } catch {}
      }
    }

    setStreaming(false)
    // Invalidate all seller data after AI might have changed something
    queryClient.invalidateQueries({ queryKey: ['products'] })
    queryClient.invalidateQueries({ queryKey: ['store'] })
    queryClient.invalidateQueries({ queryKey: ['orders'] })
  }

  return { sendMessage }
}
```

---

## REALTIME ORDER TRACKING

```ts
// hooks/useRealtime.ts
import { useEffect } from 'react'
import { useQueryClient } from '@tanstack/react-query'
import { createSupabaseBrowserClient } from '@/lib/supabase/client'

export function useOrderRealtime(orderId: string) {
  const queryClient = useQueryClient()
  const supabase = createSupabaseBrowserClient()

  useEffect(() => {
    const channel = supabase
      .channel(`order-${orderId}`)
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'orders',
        filter: `id=eq.${orderId}`,
      }, () => queryClient.invalidateQueries({ queryKey: ['order', orderId] }))
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'shipments',
        filter: `order_id=eq.${orderId}`,
      }, () => queryClient.invalidateQueries({ queryKey: ['order', orderId] }))
      .subscribe()

    return () => { supabase.removeChannel(channel) }
  }, [orderId])
}
```

---

## R2 FILE UPLOAD HELPER

```ts
// lib/r2.ts
import { S3Client, PutObjectCommand, DeleteObjectCommand } from '@aws-sdk/client-s3'
import { getSignedUrl } from '@aws-sdk/s3-request-presigner'

const r2 = new S3Client({
  region: 'auto',
  endpoint: `https://${process.env.CLOUDFLARE_ACCOUNT_ID}.r2.cloudflarestorage.com`,
  credentials: {
    accessKeyId: process.env.CLOUDFLARE_R2_ACCESS_KEY!,
    secretAccessKey: process.env.CLOUDFLARE_R2_SECRET_KEY!,
  },
})

export async function uploadToR2(key: string, file: Buffer, contentType: string) {
  await r2.send(new PutObjectCommand({
    Bucket: process.env.CLOUDFLARE_R2_BUCKET!,
    Key: key,
    Body: file,
    ContentType: contentType,
  }))
  return `${process.env.CLOUDFLARE_R2_PUBLIC_URL}/${key}`
}

export async function getPresignedUploadUrl(key: string, contentType: string) {
  return getSignedUrl(r2, new PutObjectCommand({
    Bucket: process.env.CLOUDFLARE_R2_BUCKET!,
    Key: key,
    ContentType: contentType,
  }), { expiresIn: 3600 })
}
```

---

## DATA FETCHING PATTERNS

```ts
// Server Component (SSR) — for SEO pages
export default async function ProductPage({ params }: { params: { id: string } }) {
  const supabase = createSupabaseServerClient()
  const { data: product } = await supabase
    .from('products')
    .select('*, stores(*), product_images(*), categories(*)')
    .eq('id', params.id)
    .single()

  if (!product) notFound()
  return <ProductDetail product={product} />
}

// Client Component — for dashboard (TanStack Query)
function ProductList() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['seller-products'],
    queryFn: () => fetch('/api/seller/products').then(r => r.json()).then(r => r.data),
  })
  if (isLoading) return <SkeletonTable />
  if (error) return <ErrorState message="Gagal memuat produk" />
  return <DataTable data={data} columns={productColumns} />
}

// Mutation example
const createProduct = useMutation({
  mutationFn: (data: ProductInput) =>
    fetch('/api/seller/products', { method: 'POST', body: JSON.stringify(data) }).then(r => r.json()),
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['seller-products'] })
    toast.success('Produk berhasil ditambahkan!')
  },
  onError: () => toast.error('Gagal menambahkan produk'),
})
```

---

## UTILITY FUNCTIONS

```ts
// lib/utils.ts
import { clsx, type ClassValue } from 'clsx'
import { twMerge } from 'tailwind-merge'

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function formatPrice(amount: number) {
  return new Intl.NumberFormat('id-ID', { style: 'currency', currency: 'IDR', minimumFractionDigits: 0 }).format(amount)
  // Output: "Rp 15.000"
}

export function formatDate(date: string | Date) {
  return new Intl.DateTimeFormat('id-ID', { day: 'numeric', month: 'long', year: 'numeric' }).format(new Date(date))
}

export function generateSlug(text: string) {
  return text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '')
}
```
